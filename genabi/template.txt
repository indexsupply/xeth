{{ define "package" }}
// Parse event/log data based on the '{{ . }}' ABI
//
// Code generated by "genabi"; DO NOT EDIT.
package {{ . }}
{{ end }}

{{ define "imports" }}
import (
	{{ range . -}}
	"{{ . }}"
	{{ end -}}
)
{{ end }}

{{ define "struct" -}}
	{{ if not .AlreadyDefined -}}
	type {{camel .Name }} struct {
		item *abi.Item

		{{ if gt (len (indexed .Inputs)) 0 -}}
		// Indexed:
		{{ end -}}
		{{ range (indexed .Inputs) -}}
			{{ camel .Name }} {{ goType . }}
		{{ end -}}
		{{ if gt (len (unindexed .Inputs)) 0 -}}
		// Un-indexed:
		{{ end -}}
		{{ range (unindexed .Inputs) -}}
			{{ camel .Name }} {{ goType . }}
		{{ end -}}
	}

	func (x {{ camel .Name }}) Done() {
		x.item.Done()
	}

	func decode{{ camel .Name }}(item *abi.Item) {{ camel .Name }} {
		x := {{ camel .Name }}{}
		{{ range $index, $inp := (unindexed .Inputs) -}}
			{{ if isTuple $inp -}}
				x.{{ camel $inp.Name }} = decode{{ camel $inp.Name }}(item.At({{ $index }}))
			{{ else if isArray $inp -}}
				{{ template "list" listHelper $index $inp -}}
				x.{{ camel $inp.Name }} = {{ $inp.Name }}0
			{{ else -}}
				x.{{ camel $inp.Name }} = item.At({{ $index }}).{{ itemFunc $inp }}
			{{ end -}}
		{{ end -}}
		return x
	}

	{{ range $index, $inp := .Inputs -}}
		{{ if gt (len $inp.Components) 0  -}}
			{{ template "struct" structHelper $inp.Name $inp.Components -}}
		{{ end -}}
	{{ end -}}
	{{ end -}}
{{ end -}}

{{ define "list" -}}
	{{ if .Nested -}}
		{{ .Input.Name }}Item{{ .Index }} := {{ .Input.Name }}Item{{ sub .Index 1 }}.At(i{{ sub .Index 1 }})
	{{ else -}}
		{{ .Input.Name }}Item{{ .Index }} := item.At({{ .ItemIndex }})
	{{ end -}}
	{{ if .FixedLength -}}
		{{ .Input.Name }}{{ .Index }} := {{ .MakeArg }}{}
	{{ else -}}
		{{ .Input.Name }}{{ .Index }} := make({{ .MakeArg }}, {{ .Input.Name }}Item{{ .Index }}.Len())
	{{ end -}}
	{{ if .HasNext -}}
		for i{{ .Index }} := 0; i{{ .Index }} < {{ .Input.Name }}Item{{ .Index }}.Len(); i{{ .Index }}++ {
			{{ template "list" .Next -}}
			{{ .Input.Name}}{{ .Index }}[i{{ .Index }}] = {{ .Input.Name }}{{ add .Index 1}}
		}
	{{ else -}}
		for i{{ .Index }} := 0; i{{ .Index }} < {{ .Input.Name }}Item{{ .Index }}.Len(); i{{ .Index }}++ {
			{{ if hasTuple .Input -}}
				{{ .Input.Name}}{{ .Index }}[i{{ .Index }}] = decode{{ camel .Input.Name }}({{ .Input.Name }}Item{{ .Index }}.At(i{{ .Index}}))
			{{ else -}}
				{{ .Input.Name}}{{ .Index }}[i{{ .Index }}] = {{ .Input.Name }}Item{{ .Index }}.At(i{{ .Index}}).{{ itemFunc .Input }}
			{{ end -}}
		}
	{{ end -}}
{{ end -}}

{{- define "event" -}}
	{{ template "struct" structHelper .Name .Inputs -}}

	var (
		{{ lower .Name }}Signature = {{ .SigHashLiteral }}
		{{ lower .Name }}Schema = schema.Parse("{{ .SchemaSignature }}")
		{{ lower .Name }}NumIndexed = int({{ len (indexed .Inputs) }})
	)

	// Event Signature:
	//	{{ .Signature }}
	// Checks the first log topic against the signature hash:
	//	{{ printf "%x" .SignatureHash }}
	//
	// Copies indexed event inputs from the remaining topics
	// into [{{ camel .Name }}]
	//
	// Uses the the following abi schema to decode the un-indexed
	// event inputs from the log's data field into [{{ camel .Name }}]:
	//	{{ .SchemaSignature }}
	func Match{{ camel .Name }}(l abi.Log) ({{ camel .Name}}, error) {
		if len(l.Topics) == 0 {
			return {{ camel .Name }}{}, abi.NoTopics
		}
		if len(l.Topics) > 0 && {{ lower .Name }}Signature != l.Topics[0] {
			return {{ camel .Name }}{}, abi.SigMismatch
		}
		if len(l.Topics[1:]) != {{ lower .Name }}NumIndexed {
			return {{ camel .Name }}{}, abi.IndexMismatch
		}
		{{ if gt (len (unindexed .Inputs)) 0 -}}
			item, _, err := abi.Decode(l.Data, {{ lower .Name }}Schema)
			if err != nil {
				return {{ camel .Name }}{}, err
			}
			res := decode{{ camel .Name}}(item)
			res.item = item
		{{ else -}}
			res := {{ camel .Name}}{}
		{{ end -}}
		{{ range $index, $inp := (indexed .Inputs) -}}
			res.{{ camel $inp.Name }} = abi.Bytes(l.Topics[{{ add $index  1 }}][:]).{{ itemFunc $inp }}
		{{ end -}}
		return res, nil
	}
{{ end -}}
