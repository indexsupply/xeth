{{ define "package" }}
// View functions and log parsing from {{ .InputFile }}
//
// Code generated by "genabi"; DO NOT EDIT.
package {{ .PackageName }}
{{ end }}

{{ define "imports" }}
import (
	{{ range . -}}
	"{{ . }}"
	{{ end -}}
)
{{ end }}

{{- /*
	array-encode turns an array(slice) field on a struct into
	a properly formed abi.Item. The resulting code should look
	like the following:

	Un-nested:
	var (
		field0 = x.Field
		fieldItems0 = make([]*abi.Item, len(field0))
	)
	for i0 := 0; i0 < len(field0); i0++ {
		fieldItems0[i0] = abi.ƒ(field0[i0])
	}

	Nested:
	var (
		field0 = x.Field
		fieldItems0 = make([]*abi.Item, len(field0))
	)
	for i0 := 0; i0 < len(field0); i0++ {
		var (
			field1 = field0[i0]
			fieldItems1 = make([]*abi.Item, len(field1))
		)
		for i1 := 0; i1 < len(field1); i1++ {
			fieldItems1[i1] = abi.ƒ(field1[i1])
		}
		fieldItems0[i0] = abi.Array(fieldItems1...)
	}

	array-decode turns an array abi.Item into a Go array(slice).
	The resulting code should look like the following:

	Un-nested:
	var (
		xItem0 = item.At(0)
		x0 = make(T, xItem0.Len()) // will vary if fixed-length
	)
	for i0 := 0; i0 < xItem0.Len(); i0++ {
		x0[i0] = xItem0.At(i0).ƒ()
	}

	Nested:
	var (
		xItem0 = item.At(0)
		x0 = make(T, xItem0.Len()) // will vary if fixed-length
	)
	for i0 := 0; i0 < xItem0.Len(); i0++ {
		var (
			xItem1 = xItem0.At(i0)
			x1 = make(T, xItem1.Len())
		)
		for i1 := 0; i1 < xItem1.Len(); i1++ {
			x1[i1] = xItem1.At(i1).ƒ()
		}
		x0[i0] = x1
	}
*/ -}}

{{- define "array-encode" -}}
	var (
		{{ if .Nested -}}
			{{ lower .Field.Name }}{{ .Index }} = {{ lower .Field.Name }}{{ sub .Index 1 }}[i{{ sub .Index 1}}]
		{{ else -}}
			{{ lower .Field.Name }}{{ .Index }} = x.{{ camel .Field.Name }}
		{{ end -}}
		{{ lower .Field.Name }}Items{{.Index }} = make([]*abi.Item, len({{ lower .Field.Name }}{{ .Index }}))
	)
	for i{{ .Index }} := 0; i{{ .Index }} < len({{ lower .Field.Name }}{{ .Index }}); i{{ .Index }}++ {
		{{ if .HasNext -}}
			{{ template "array-encode" .Next }}
			{{ lower .Field.Name }}Items{{ .Index }}[i{{ .Index }}] = abi.Array({{ lower .Field.Name }}Items{{ .Index }}...)
		{{ else -}}
			{{ if hasTuple .Field -}}
				{{ lower .Field.Name }}Items{{ .Index }}[i{{ .Index }}] = {{ lower .Field.Name }}{{ .Index }}[i{{ .Index }}].Encode()
			{{ else -}}
				{{ lower .Field.Name }}Items{{ .Index }}[i{{ .Index }}] = abi.{{ itemFunc .Field.Type }}({{ lower .Field.Name }}{{ .Index }}[i{{ .Index }}])
			{{ end -}}
		{{ end -}}
	}
{{ end -}}

{{ define "array-decode" -}}
	var (
		{{ if .Nested -}}
			{{ .Field.Name }}Item{{ .Index }} = {{ .Field.Name }}Item{{ sub .Index 1 }}.At(i{{ sub .Index 1 }})
		{{ else -}}
			{{ .Field.Name }}Item{{ .Index }} = item.At({{ .ItemIndex }})
		{{ end -}}
		{{ if .FixedLength -}}
			{{ .Field.Name }}{{ .Index }} = {{ .Type (camel (goType .Field.Type (printf "%s_%s" .StructName .Field.Name))) }}{}
		{{ else -}}
			{{ .Field.Name }}{{ .Index }} = make({{ .Type (camel (goType .Field.Type (printf "%s_%s" .StructName .Field.Name))) }}, {{ .Field.Name }}Item{{ .Index }}.Len())
		{{ end -}}
	)
	for i{{ .Index }} := 0; i{{ .Index }} < {{ .Field.Name }}Item{{ .Index }}.Len(); i{{ .Index }}++ {
		{{ if .HasNext -}}
			{{ template "array-decode" .Next -}}
			{{ .Field.Name}}{{ .Index }}[i{{ .Index }}] = {{ .Field.Name }}{{ add .Index 1}}
		{{ else -}}
			{{ if hasTuple .Field -}}
				{{ .Field.Name}}{{ .Index }}[i{{ .Index }}] = Decode{{ camel (printf "%s_%s" .StructName .Field.Name) }}({{ .Field.Name }}Item{{ .Index }}.At(i{{ .Index}}))
			{{ else -}}
				{{ .Field.Name}}{{ .Index }}[i{{ .Index }}] = {{ .Field.Name }}Item{{ .Index }}.At(i{{ .Index}}).{{ itemFunc .Field.Type }}()
			{{ end -}}
		{{ end -}}
	}
{{ end -}}

{{- define "struct" -}}
{{ if not .AlreadyDefined -}}
	{{ $structName := .Name }}
	type {{camel .Name }} struct {
		item *abi.Item
		{{ range .Fields  -}}
			{{ camel .Name }} {{ goType .Type (printf "%s_%s" $structName .Name) }}
		{{ end -}}
	}

	func (x {{ camel .Name }}) Done() {
		x.item.Done()
	}

	{{ if (gt (len (unindexed .Fields)) 0) -}}
		func Decode{{ camel .Name }}(item *abi.Item) {{ camel .Name }} {
			x := {{ camel .Name }}{}
			x.item = item
			{{ range $index, $f := (unindexed .Fields) -}}
				{{ if isArray $f -}}
					{{ template "array-decode" arrayHelper $index $structName $f -}}
					x.{{ camel $f.Name }} = {{ $f.Name }}0
				{{ else if isTuple $f -}}
					x.{{ camel $f.Name }} = Decode{{ camel (printf "%s_%s" $structName $f.Name) }}(item.At({{ $index }}))
				{{ else -}}
					x.{{ camel $f.Name }} = item.At({{ $index }}).{{ itemFunc $f.Type }}()
				{{ end -}}
			{{ end -}}
			return x
		}
	{{ end }}

	func (x {{ camel .Name }}) Encode() *abi.Item {
		items := make([]*abi.Item, {{ len .Fields }})
		{{ range $i, $f := .Fields -}}
			{{ if isArray $f -}}
				{{ template "array-encode" arrayHelper 0 $structName $f -}}
				items[{{ $i }}] = abi.Array({{lower $f.Name }}Items0...)
			{{ else if isTuple $f -}}
				items[{{ $i }}] = x.{{ camel $f.Name }}.Encode()
			{{ else -}}
				items[{{ $i }}] = abi.{{ itemFunc $f.Type }}(x.{{ camel $f.Name }})
			{{ end -}}
		{{ end -}}
		return abi.Tuple(items...)
	}

	{{ range $index, $f := .Fields -}}
		{{ if gt (len $f.Components) 0  -}}
			{{ template "struct" structHelper (printf "%s_%s" $structName $f.Name) $f.Components -}}
		{{ end -}}
	{{ end -}}
{{ end -}}
{{ end -}}

{{- define "function" -}}
	{{ if (gt (len .Inputs) 0) -}}
		{{ template "struct" structHelper (printf "%sRequest" .Name) .Inputs -}}
	{{ end -}}
	{{ if (gt (len .Outputs) 0) -}}
		{{ template "struct" structHelper (printf "%sResponse" .Name) .Outputs -}}
	{{ end -}}
	var (
		{{ camel .Name }}RequestSignature = {{ (hashLiteral (keccak .InputSignature)) }}
		{{ camel .Name }}ResponseSchema = schema.Parse("{{ schema .Outputs }}")
	)
	{{ if eq .StateMutability "view" -}}
		{{ if (eq (len .Inputs) 0) -}}
			func Call{{ camel .Name }}(c *jrpc.Client, contract [20]byte) ({{ camel .Name }}Response, error ) {
				respData, err := c.EthCall(contract, {{ camel .Name }}RequestSignature[:4])
				if err != nil {
					return {{ camel .Name }}Response{}, err
				}
				respItem, _, err := abi.Decode(respData, {{ camel .Name }}ResponseSchema)
				defer respItem.Done()
				if err != nil {
					return {{ camel .Name }}Response{}, err
				}
				return Decode{{ camel .Name }}Response(respItem), nil
			}
		{{ else -}}
			func Call{{ camel .Name }}(c *jrpc.Client, contract [20]byte, req {{ camel .Name }}Request) ({{ camel .Name }}Response, error ) {
				var (
					s4 = {{ camel .Name }}RequestSignature[:4]
					cd = append(s4, abi.Encode(req.Encode())...)
				)
				respData, err := c.EthCall(contract, cd)
				if err != nil {
					return {{ camel .Name }}Response{}, err
				}
				respItem, _, err := abi.Decode(respData, {{ camel .Name }}ResponseSchema)
				defer respItem.Done()
				if err != nil {
					return {{ camel .Name }}Response{}, err
				}
				return Decode{{ camel .Name }}Response(respItem), nil
			}
		{{ end -}}
	{{ end -}}
{{ end -}}

{{- define "event" -}}
	{{ template "struct" structHelper (printf "%sEvent" .Name) .Inputs -}}

	var (
		{{ camel .Name }}Signature = {{ (hashLiteral (keccak .InputSignature))  }}
		{{ camel .Name }}Schema = schema.Parse("{{ schema (unindexed .Inputs) }}")
		{{ camel .Name }}NumIndexed = int({{ len (indexed .Inputs) }})
	)

	// Event Signature:
	//	{{ .InputSignature }}
	// Checks the first log topic against the signature hash:
	//	{{ printf "%x" (keccak .InputSignature) }}
	//
	// Copies indexed event inputs from the remaining topics
	// into [{{ camel .Name }}]
	//
	// Uses the the following abi schema to decode the un-indexed
	// event inputs from the log's data field into [{{ camel .Name }}]:
	//	{{ (schema (unindexed .Inputs))}}
	func Match{{ camel .Name }}(l eth.Log) ({{ camel .Name}}Event, error) {
		if l.Topics.Len() <= 0 {
			return {{ camel .Name }}Event{}, abi.NoTopics
		}
		if !bytes.Equal({{ camel .Name }}Signature, l.Topics.At(0)) {
			return {{ camel .Name }}Event{}, abi.SigMismatch
		}
		if l.Topics.Len() - 1 != {{ camel .Name }}NumIndexed {
			return {{ camel .Name }}Event{}, abi.IndexMismatch
		}
		{{ if gt (len (unindexed .Inputs)) 0 -}}
			item, _, err := abi.Decode(l.Data, {{ camel .Name }}Schema)
			if err != nil {
				return {{ camel .Name }}Event{}, err
			}
			res := Decode{{ camel .Name}}Event(item)
		{{ else -}}
			res := {{ camel .Name}}Event{}
		{{ end -}}
		{{ range $index, $inp := (indexed .Inputs) -}}
			res.{{ camel $inp.Name }} = abi.Bytes(l.Topics.At({{ add $index  1 }})).{{ itemFunc $inp.Type }}()
		{{ end -}}
		return res, nil
	}
{{ end -}}
