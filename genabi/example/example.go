// Parse event/log data based on the 'example' ABI
//
// Code generated by "genabi"; DO NOT EDIT.
package example

import (
	"github.com/indexsupply/x/abi"
	"github.com/indexsupply/x/abi/schema"
	"math/big"
)

type NestedSlices struct {
	item *abi.Item

	// Un-indexed:
	Strings []string
}

func (x NestedSlices) Done() {
	x.item.Done()
}

func decodeNestedSlices(item *abi.Item) NestedSlices {
	x := NestedSlices{}
	stringsItem0 := item.At(0)
	strings0 := make([]string, stringsItem0.Len())
	for i0 := 0; i0 < stringsItem0.Len(); i0++ {
		strings0[i0] = stringsItem0.At(i0).String()
	}
	x.Strings = strings0
	return x
}

var (
	nestedSlicesSignature  = [32]byte{0xee, 0x41, 0x3f, 0x81, 0xe1, 0x39, 0xc0, 0xfa, 0xea, 0xfa, 0xeb, 0xcd, 0x24, 0x55, 0x1f, 0x44, 0x4, 0x1a, 0x81, 0x69, 0xd6, 0x6c, 0x58, 0x8c, 0xe7, 0x71, 0x24, 0x99, 0xda, 0xf4, 0x96, 0x13}
	nestedSlicesSchema     = schema.Parse("(string[])")
	nestedSlicesNumIndexed = int(0)
)

// Event Signature:
//	nestedSlices(string[])
// Checks the first log topic against the signature hash:
//	ee413f81e139c0faeafaebcd24551f44041a8169d66c588ce7712499daf49613
//
// Copies indexed event inputs from the remaining topics
// into [NestedSlices]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [NestedSlices]:
//	(string[])
func MatchNestedSlices(l abi.Log) (NestedSlices, error) {
	if len(l.Topics) == 0 {
		return NestedSlices{}, abi.NoTopics
	}
	if len(l.Topics) > 0 && nestedSlicesSignature != l.Topics[0] {
		return NestedSlices{}, abi.SigMismatch
	}
	if len(l.Topics[1:]) != nestedSlicesNumIndexed {
		return NestedSlices{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, nestedSlicesSchema)
	if err != nil {
		return NestedSlices{}, err
	}
	res := decodeNestedSlices(item)
	res.item = item
	return res, nil
}

type Transfer struct {
	item *abi.Item

	// Indexed:
	From [20]byte
	To   [20]byte
	Id   *big.Int
	// Un-indexed:
	Extra   [3][2]uint8
	Details [][]Details
}

func (x Transfer) Done() {
	x.item.Done()
}

func decodeTransfer(item *abi.Item) Transfer {
	x := Transfer{}
	extraItem0 := item.At(0)
	extra0 := [3][2]uint8{}
	for i0 := 0; i0 < extraItem0.Len(); i0++ {
		extraItem1 := extraItem0.At(i0)
		extra1 := [2]uint8{}
		for i1 := 0; i1 < extraItem1.Len(); i1++ {
			extra1[i1] = extraItem1.At(i1).Uint8()
		}
		extra0[i0] = extra1
	}
	x.Extra = extra0
	detailsItem0 := item.At(1)
	details0 := make([][]Details, detailsItem0.Len())
	for i0 := 0; i0 < detailsItem0.Len(); i0++ {
		detailsItem1 := detailsItem0.At(i0)
		details1 := make([]Details, detailsItem1.Len())
		for i1 := 0; i1 < detailsItem1.Len(); i1++ {
			details1[i1] = decodeDetails(detailsItem1.At(i1))
		}
		details0[i0] = details1
	}
	x.Details = details0
	return x
}

type Details struct {
	item *abi.Item

	// Un-indexed:
	Other [20]byte
	Key   [32]byte
	Value []byte
	Geo   Geo
}

func (x Details) Done() {
	x.item.Done()
}

func decodeDetails(item *abi.Item) Details {
	x := Details{}
	x.Other = item.At(0).Address()
	x.Key = item.At(1).Bytes32()
	x.Value = item.At(2).Bytes()
	x.Geo = decodeGeo(item.At(3))
	return x
}

type Geo struct {
	item *abi.Item

	// Un-indexed:
	X uint8
	Y uint8
}

func (x Geo) Done() {
	x.item.Done()
}

func decodeGeo(item *abi.Item) Geo {
	x := Geo{}
	x.X = item.At(0).Uint8()
	x.Y = item.At(1).Uint8()
	return x
}

var (
	transferSignature  = [32]byte{0x70, 0x71, 0x1f, 0x9e, 0xfd, 0x2d, 0x56, 0x86, 0x65, 0x59, 0x2c, 0x1d, 0x62, 0x45, 0xe8, 0x92, 0xea, 0xb7, 0xd9, 0xe5, 0x6c, 0x76, 0x71, 0x46, 0x82, 0x52, 0x60, 0x66, 0xca, 0x69, 0xd6, 0x5e}
	transferSchema     = schema.Parse("(uint8[2][3],(address,bytes32,bytes,(uint8,uint8))[][])")
	transferNumIndexed = int(3)
)

// Event Signature:
//	transfer(address,address,uint256,uint8[2][3],(address,bytes32,bytes,(uint8,uint8))[][])
// Checks the first log topic against the signature hash:
//	70711f9efd2d568665592c1d6245e892eab7d9e56c76714682526066ca69d65e
//
// Copies indexed event inputs from the remaining topics
// into [Transfer]
//
// Uses the the following abi schema to decode the un-indexed
// event inputs from the log's data field into [Transfer]:
//	(uint8[2][3],(address,bytes32,bytes,(uint8,uint8))[][])
func MatchTransfer(l abi.Log) (Transfer, error) {
	if len(l.Topics) == 0 {
		return Transfer{}, abi.NoTopics
	}
	if len(l.Topics) > 0 && transferSignature != l.Topics[0] {
		return Transfer{}, abi.SigMismatch
	}
	if len(l.Topics[1:]) != transferNumIndexed {
		return Transfer{}, abi.IndexMismatch
	}
	item, _, err := abi.Decode(l.Data, transferSchema)
	if err != nil {
		return Transfer{}, err
	}
	res := decodeTransfer(item)
	res.item = item
	res.From = abi.Bytes(l.Topics[1][:]).Address()
	res.To = abi.Bytes(l.Topics[2][:]).Address()
	res.Id = abi.Bytes(l.Topics[3][:]).BigInt()
	return res, nil
}
